// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.2
// source: urlfrontier.proto

package urlfrontier

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// URLFrontierClient is the client API for URLFrontier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type URLFrontierClient interface {
	//* Return the list of nodes forming the cluster the current node belongs to *
	ListNodes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StringList, error)
	//* Return the list of crawls handled by the frontier(s) *
	ListCrawls(ctx context.Context, in *Local, opts ...grpc.CallOption) (*StringList, error)
	//* Delete an entire crawl, returns the number of URLs removed this way *
	DeleteCrawl(ctx context.Context, in *DeleteCrawlMessage, opts ...grpc.CallOption) (*Long, error)
	//* Return a list of queues for a specific crawl. Can chose whether to include inactive queues (a queue is active if it has URLs due for fetching);
	//by default the service will return up to 100 results from offset 0 and exclude inactive queues.*
	ListQueues(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*QueueList, error)
	//* Stream URLs due for fetching from M queues with up to N items per queue *
	GetURLs(ctx context.Context, in *GetParams, opts ...grpc.CallOption) (URLFrontier_GetURLsClient, error)
	//* Push URL items to the server; they get created (if they don't already exist) in case of DiscoveredURLItems or updated if KnownURLItems *
	PutURLs(ctx context.Context, opts ...grpc.CallOption) (URLFrontier_PutURLsClient, error)
	//* Return stats for a specific queue or an entire crawl. Does not aggregate the stats across different crawlids. *
	GetStats(ctx context.Context, in *QueueWithinCrawlParams, opts ...grpc.CallOption) (*Stats, error)
	//* Delete the queue based on the key in parameter, returns the number of URLs removed this way *
	DeleteQueue(ctx context.Context, in *QueueWithinCrawlParams, opts ...grpc.CallOption) (*Long, error)
	//* Block a queue from sending URLs; the argument is the number of seconds of UTC time since Unix epoch
	//1970-01-01T00:00:00Z. The default value of 0 will unblock the queue. The block will get removed once the time
	//indicated in argument is reached. This is useful for cases where a server returns a Retry-After for instance.
	BlockQueueUntil(ctx context.Context, in *BlockQueueParams, opts ...grpc.CallOption) (*Empty, error)
	//* De/activate the crawl. GetURLs will not return anything until SetActive is set to true. PutURLs will still take incoming data. *
	SetActive(ctx context.Context, in *Active, opts ...grpc.CallOption) (*Empty, error)
	//* Returns true if the crawl is active, false if it has been deactivated with SetActive(Boolean) *
	GetActive(ctx context.Context, in *Local, opts ...grpc.CallOption) (*Boolean, error)
	//* Set a delay from a given queue.
	//No URLs will be obtained via GetURLs for this queue until the number of seconds specified has
	//elapsed since the last time URLs were retrieved.
	//Usually informed by the delay setting of robots.txt.
	SetDelay(ctx context.Context, in *QueueDelayParams, opts ...grpc.CallOption) (*Empty, error)
	//* Overrides the log level for a given package *
	SetLogLevel(ctx context.Context, in *LogLevelParams, opts ...grpc.CallOption) (*Empty, error)
}

type uRLFrontierClient struct {
	cc grpc.ClientConnInterface
}

func NewURLFrontierClient(cc grpc.ClientConnInterface) URLFrontierClient {
	return &uRLFrontierClient{cc}
}

func (c *uRLFrontierClient) ListNodes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StringList, error) {
	out := new(StringList)
	err := c.cc.Invoke(ctx, "/urlfrontier.URLFrontier/ListNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uRLFrontierClient) ListCrawls(ctx context.Context, in *Local, opts ...grpc.CallOption) (*StringList, error) {
	out := new(StringList)
	err := c.cc.Invoke(ctx, "/urlfrontier.URLFrontier/ListCrawls", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uRLFrontierClient) DeleteCrawl(ctx context.Context, in *DeleteCrawlMessage, opts ...grpc.CallOption) (*Long, error) {
	out := new(Long)
	err := c.cc.Invoke(ctx, "/urlfrontier.URLFrontier/DeleteCrawl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uRLFrontierClient) ListQueues(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*QueueList, error) {
	out := new(QueueList)
	err := c.cc.Invoke(ctx, "/urlfrontier.URLFrontier/ListQueues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uRLFrontierClient) GetURLs(ctx context.Context, in *GetParams, opts ...grpc.CallOption) (URLFrontier_GetURLsClient, error) {
	stream, err := c.cc.NewStream(ctx, &URLFrontier_ServiceDesc.Streams[0], "/urlfrontier.URLFrontier/GetURLs", opts...)
	if err != nil {
		return nil, err
	}
	x := &uRLFrontierGetURLsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type URLFrontier_GetURLsClient interface {
	Recv() (*URLInfo, error)
	grpc.ClientStream
}

type uRLFrontierGetURLsClient struct {
	grpc.ClientStream
}

func (x *uRLFrontierGetURLsClient) Recv() (*URLInfo, error) {
	m := new(URLInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *uRLFrontierClient) PutURLs(ctx context.Context, opts ...grpc.CallOption) (URLFrontier_PutURLsClient, error) {
	stream, err := c.cc.NewStream(ctx, &URLFrontier_ServiceDesc.Streams[1], "/urlfrontier.URLFrontier/PutURLs", opts...)
	if err != nil {
		return nil, err
	}
	x := &uRLFrontierPutURLsClient{stream}
	return x, nil
}

type URLFrontier_PutURLsClient interface {
	Send(*URLItem) error
	Recv() (*AckMessage, error)
	grpc.ClientStream
}

type uRLFrontierPutURLsClient struct {
	grpc.ClientStream
}

func (x *uRLFrontierPutURLsClient) Send(m *URLItem) error {
	return x.ClientStream.SendMsg(m)
}

func (x *uRLFrontierPutURLsClient) Recv() (*AckMessage, error) {
	m := new(AckMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *uRLFrontierClient) GetStats(ctx context.Context, in *QueueWithinCrawlParams, opts ...grpc.CallOption) (*Stats, error) {
	out := new(Stats)
	err := c.cc.Invoke(ctx, "/urlfrontier.URLFrontier/GetStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uRLFrontierClient) DeleteQueue(ctx context.Context, in *QueueWithinCrawlParams, opts ...grpc.CallOption) (*Long, error) {
	out := new(Long)
	err := c.cc.Invoke(ctx, "/urlfrontier.URLFrontier/DeleteQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uRLFrontierClient) BlockQueueUntil(ctx context.Context, in *BlockQueueParams, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/urlfrontier.URLFrontier/BlockQueueUntil", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uRLFrontierClient) SetActive(ctx context.Context, in *Active, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/urlfrontier.URLFrontier/SetActive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uRLFrontierClient) GetActive(ctx context.Context, in *Local, opts ...grpc.CallOption) (*Boolean, error) {
	out := new(Boolean)
	err := c.cc.Invoke(ctx, "/urlfrontier.URLFrontier/GetActive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uRLFrontierClient) SetDelay(ctx context.Context, in *QueueDelayParams, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/urlfrontier.URLFrontier/SetDelay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uRLFrontierClient) SetLogLevel(ctx context.Context, in *LogLevelParams, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/urlfrontier.URLFrontier/SetLogLevel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// URLFrontierServer is the server API for URLFrontier service.
// All implementations must embed UnimplementedURLFrontierServer
// for forward compatibility
type URLFrontierServer interface {
	//* Return the list of nodes forming the cluster the current node belongs to *
	ListNodes(context.Context, *Empty) (*StringList, error)
	//* Return the list of crawls handled by the frontier(s) *
	ListCrawls(context.Context, *Local) (*StringList, error)
	//* Delete an entire crawl, returns the number of URLs removed this way *
	DeleteCrawl(context.Context, *DeleteCrawlMessage) (*Long, error)
	//* Return a list of queues for a specific crawl. Can chose whether to include inactive queues (a queue is active if it has URLs due for fetching);
	//by default the service will return up to 100 results from offset 0 and exclude inactive queues.*
	ListQueues(context.Context, *Pagination) (*QueueList, error)
	//* Stream URLs due for fetching from M queues with up to N items per queue *
	GetURLs(*GetParams, URLFrontier_GetURLsServer) error
	//* Push URL items to the server; they get created (if they don't already exist) in case of DiscoveredURLItems or updated if KnownURLItems *
	PutURLs(URLFrontier_PutURLsServer) error
	//* Return stats for a specific queue or an entire crawl. Does not aggregate the stats across different crawlids. *
	GetStats(context.Context, *QueueWithinCrawlParams) (*Stats, error)
	//* Delete the queue based on the key in parameter, returns the number of URLs removed this way *
	DeleteQueue(context.Context, *QueueWithinCrawlParams) (*Long, error)
	//* Block a queue from sending URLs; the argument is the number of seconds of UTC time since Unix epoch
	//1970-01-01T00:00:00Z. The default value of 0 will unblock the queue. The block will get removed once the time
	//indicated in argument is reached. This is useful for cases where a server returns a Retry-After for instance.
	BlockQueueUntil(context.Context, *BlockQueueParams) (*Empty, error)
	//* De/activate the crawl. GetURLs will not return anything until SetActive is set to true. PutURLs will still take incoming data. *
	SetActive(context.Context, *Active) (*Empty, error)
	//* Returns true if the crawl is active, false if it has been deactivated with SetActive(Boolean) *
	GetActive(context.Context, *Local) (*Boolean, error)
	//* Set a delay from a given queue.
	//No URLs will be obtained via GetURLs for this queue until the number of seconds specified has
	//elapsed since the last time URLs were retrieved.
	//Usually informed by the delay setting of robots.txt.
	SetDelay(context.Context, *QueueDelayParams) (*Empty, error)
	//* Overrides the log level for a given package *
	SetLogLevel(context.Context, *LogLevelParams) (*Empty, error)
	mustEmbedUnimplementedURLFrontierServer()
}

// UnimplementedURLFrontierServer must be embedded to have forward compatible implementations.
type UnimplementedURLFrontierServer struct {
}

func (UnimplementedURLFrontierServer) ListNodes(context.Context, *Empty) (*StringList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNodes not implemented")
}
func (UnimplementedURLFrontierServer) ListCrawls(context.Context, *Local) (*StringList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCrawls not implemented")
}
func (UnimplementedURLFrontierServer) DeleteCrawl(context.Context, *DeleteCrawlMessage) (*Long, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCrawl not implemented")
}
func (UnimplementedURLFrontierServer) ListQueues(context.Context, *Pagination) (*QueueList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListQueues not implemented")
}
func (UnimplementedURLFrontierServer) GetURLs(*GetParams, URLFrontier_GetURLsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetURLs not implemented")
}
func (UnimplementedURLFrontierServer) PutURLs(URLFrontier_PutURLsServer) error {
	return status.Errorf(codes.Unimplemented, "method PutURLs not implemented")
}
func (UnimplementedURLFrontierServer) GetStats(context.Context, *QueueWithinCrawlParams) (*Stats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStats not implemented")
}
func (UnimplementedURLFrontierServer) DeleteQueue(context.Context, *QueueWithinCrawlParams) (*Long, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQueue not implemented")
}
func (UnimplementedURLFrontierServer) BlockQueueUntil(context.Context, *BlockQueueParams) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockQueueUntil not implemented")
}
func (UnimplementedURLFrontierServer) SetActive(context.Context, *Active) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetActive not implemented")
}
func (UnimplementedURLFrontierServer) GetActive(context.Context, *Local) (*Boolean, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActive not implemented")
}
func (UnimplementedURLFrontierServer) SetDelay(context.Context, *QueueDelayParams) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDelay not implemented")
}
func (UnimplementedURLFrontierServer) SetLogLevel(context.Context, *LogLevelParams) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLogLevel not implemented")
}
func (UnimplementedURLFrontierServer) mustEmbedUnimplementedURLFrontierServer() {}

// UnsafeURLFrontierServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to URLFrontierServer will
// result in compilation errors.
type UnsafeURLFrontierServer interface {
	mustEmbedUnimplementedURLFrontierServer()
}

func RegisterURLFrontierServer(s grpc.ServiceRegistrar, srv URLFrontierServer) {
	s.RegisterService(&URLFrontier_ServiceDesc, srv)
}

func _URLFrontier_ListNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(URLFrontierServer).ListNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/urlfrontier.URLFrontier/ListNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(URLFrontierServer).ListNodes(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _URLFrontier_ListCrawls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Local)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(URLFrontierServer).ListCrawls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/urlfrontier.URLFrontier/ListCrawls",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(URLFrontierServer).ListCrawls(ctx, req.(*Local))
	}
	return interceptor(ctx, in, info, handler)
}

func _URLFrontier_DeleteCrawl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCrawlMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(URLFrontierServer).DeleteCrawl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/urlfrontier.URLFrontier/DeleteCrawl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(URLFrontierServer).DeleteCrawl(ctx, req.(*DeleteCrawlMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _URLFrontier_ListQueues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(URLFrontierServer).ListQueues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/urlfrontier.URLFrontier/ListQueues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(URLFrontierServer).ListQueues(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

func _URLFrontier_GetURLs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetParams)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(URLFrontierServer).GetURLs(m, &uRLFrontierGetURLsServer{stream})
}

type URLFrontier_GetURLsServer interface {
	Send(*URLInfo) error
	grpc.ServerStream
}

type uRLFrontierGetURLsServer struct {
	grpc.ServerStream
}

func (x *uRLFrontierGetURLsServer) Send(m *URLInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _URLFrontier_PutURLs_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(URLFrontierServer).PutURLs(&uRLFrontierPutURLsServer{stream})
}

type URLFrontier_PutURLsServer interface {
	Send(*AckMessage) error
	Recv() (*URLItem, error)
	grpc.ServerStream
}

type uRLFrontierPutURLsServer struct {
	grpc.ServerStream
}

func (x *uRLFrontierPutURLsServer) Send(m *AckMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *uRLFrontierPutURLsServer) Recv() (*URLItem, error) {
	m := new(URLItem)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _URLFrontier_GetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueWithinCrawlParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(URLFrontierServer).GetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/urlfrontier.URLFrontier/GetStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(URLFrontierServer).GetStats(ctx, req.(*QueueWithinCrawlParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _URLFrontier_DeleteQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueWithinCrawlParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(URLFrontierServer).DeleteQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/urlfrontier.URLFrontier/DeleteQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(URLFrontierServer).DeleteQueue(ctx, req.(*QueueWithinCrawlParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _URLFrontier_BlockQueueUntil_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockQueueParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(URLFrontierServer).BlockQueueUntil(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/urlfrontier.URLFrontier/BlockQueueUntil",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(URLFrontierServer).BlockQueueUntil(ctx, req.(*BlockQueueParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _URLFrontier_SetActive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Active)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(URLFrontierServer).SetActive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/urlfrontier.URLFrontier/SetActive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(URLFrontierServer).SetActive(ctx, req.(*Active))
	}
	return interceptor(ctx, in, info, handler)
}

func _URLFrontier_GetActive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Local)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(URLFrontierServer).GetActive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/urlfrontier.URLFrontier/GetActive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(URLFrontierServer).GetActive(ctx, req.(*Local))
	}
	return interceptor(ctx, in, info, handler)
}

func _URLFrontier_SetDelay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueDelayParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(URLFrontierServer).SetDelay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/urlfrontier.URLFrontier/SetDelay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(URLFrontierServer).SetDelay(ctx, req.(*QueueDelayParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _URLFrontier_SetLogLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogLevelParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(URLFrontierServer).SetLogLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/urlfrontier.URLFrontier/SetLogLevel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(URLFrontierServer).SetLogLevel(ctx, req.(*LogLevelParams))
	}
	return interceptor(ctx, in, info, handler)
}

// URLFrontier_ServiceDesc is the grpc.ServiceDesc for URLFrontier service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var URLFrontier_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "urlfrontier.URLFrontier",
	HandlerType: (*URLFrontierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListNodes",
			Handler:    _URLFrontier_ListNodes_Handler,
		},
		{
			MethodName: "ListCrawls",
			Handler:    _URLFrontier_ListCrawls_Handler,
		},
		{
			MethodName: "DeleteCrawl",
			Handler:    _URLFrontier_DeleteCrawl_Handler,
		},
		{
			MethodName: "ListQueues",
			Handler:    _URLFrontier_ListQueues_Handler,
		},
		{
			MethodName: "GetStats",
			Handler:    _URLFrontier_GetStats_Handler,
		},
		{
			MethodName: "DeleteQueue",
			Handler:    _URLFrontier_DeleteQueue_Handler,
		},
		{
			MethodName: "BlockQueueUntil",
			Handler:    _URLFrontier_BlockQueueUntil_Handler,
		},
		{
			MethodName: "SetActive",
			Handler:    _URLFrontier_SetActive_Handler,
		},
		{
			MethodName: "GetActive",
			Handler:    _URLFrontier_GetActive_Handler,
		},
		{
			MethodName: "SetDelay",
			Handler:    _URLFrontier_SetDelay_Handler,
		},
		{
			MethodName: "SetLogLevel",
			Handler:    _URLFrontier_SetLogLevel_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetURLs",
			Handler:       _URLFrontier_GetURLs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PutURLs",
			Handler:       _URLFrontier_PutURLs_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "urlfrontier.proto",
}
